require import Ring Number StdRing StdOrder List FSet Int IntExtra IntDiv.
require (*--*) FinType.
(*---*) import IntID IntOrder.

pragma -oldip. pragma +implicits.

(**************************************************************************)
clone include Ring.ZModule.

op g     : t.
op order : int.

abbrev gpow n = intmul g n.

op enum = map gpow (range 0 order) axiomatized by enumE.

axiom genum_spec : forall x, count (pred1 x) enum = 1.

clone include FinType with
  type t    <- t,
  op   enum <- enum
proof enum_spec by exact/genum_spec.

lemma gen_spec x : exists i, 0 <= i < order /\ x = gpow i.
proof.
by move: (enumP x); rewrite enumE => /mapP[i] [] /mem_range ??; exists i.
qed.

lemma gt0_order: 0 < order.
proof. by case: (gen_spec witness) => i [] + _ /#. qed.

hint exact : gt0_order.

lemma gpow0 : gpow 0 = zeror.
proof. by rewrite mulr0z. qed.

lemma gpow1 : gpow 1 = g.
proof. by rewrite mulr1z. qed.

lemma gpowS m : gpow (m + 1) = g + gpow m.
proof. by rewrite mulrSz. qed.

lemma gpowD (m n : int) : gpow (m + n) = gpow m + gpow n.
proof. by rewrite -mulrzz_add. qed.

lemma gpowN (m : int) : gpow (-m) = - gpow m.
proof. by rewrite -mulrNz. qed.

lemma gpowB (m n : int) : gpow (m - n) = gpow m - gpow n.
proof. by rewrite gpowD gpowN. qed.

lemma glog_inj m n :
     0 <= m < order
  => 0 <= n < order
  => gpow m = gpow n
  => m = n.
proof.
wlog: m n / (n <= m) => [wlog|le_nm] rgm rgn.
  by case: (leVge n m) => /wlog + ? - ->//; apply/eq_sym.
rewrite -subr_eq0 -gpowB => heq.
have := enum_spec (gpow (m - n)); rewrite enumE.
rewrite heq range_ltn //= gpow0 b2i1 addrC -subr_eq0 addrK.
rewrite -count_eq0 has_pred1 &(contraR) => neq_mn.
by rewrite -heq &(@map_f gpow) mem_range /#.
qed.

lemma gpow_order : gpow order = zeror.
proof.
case: (gen_spec (gpow order)) => k [] [+ lt_ko].
case/ler_eqVlt => [<-|gt0_k]; first by rewrite gpow0.
rewrite -subr_eq0 -gpowB -{1}gpow0 => h.
by have := glog_inj _ _ _ _ h => // /#.
qed.

lemma gpow_ediv d m : gpow (d * order + m) = gpow m.
proof.
rewrite gpowD -subr_eq0 addrK; elim/intwlog: d.
+ by move=> d; rewrite mulNr gpowN oppr_eq0.
+ by rewrite gpow0.
move=> d ihd; rewrite mulrDl /= gpowD => ->.
by rewrite add0r gpow_order.
qed.

lemma gpow_mul_order d : gpow (d * order) = zeror.
proof. by rewrite (@gpow_ediv d 0) gpow0. qed.

lemma gpow_mod_order n: gpow (n %% order) = gpow n.
proof. by rewrite {2}(@divz_eq n order) gpowD gpow_mul_order add0r. qed.

lemma glog_inj_mod m n :
  gpow m = gpow n => m %% order = n %% order.
proof.
rewrite -(@gpow_mod_order m) -(@gpow_mod_order n) &(glog_inj);
  by rewrite ltz_pmod //= modz_ge0 gtr_eqF.
qed.

lemma gpow_eq0P n : order %| n <=> gpow n = zeror.
proof. split.
+ by case/dvdzP=> q ->; rewrite gpow_mul_order.
+ by rewrite -gpow0 /(%|) -{2}(@mod0z order); apply: glog_inj_mod.
qed.

(**************************************************************************)
(* The rest of this file is currently experimentation
   with Lagrange-related facts. They don't need cyclicity                 *)
(**************************************************************************)
op subgroup (s : t fset) =
  zeror \in s /\
  forall x y, x \in s => y \in s => (x - y) \in s.

lemma subgroup0 (s : t fset):
  subgroup s => zeror \in s.
proof. by move=> []. qed.

lemma subgroup_opp (s : t fset) x:
  subgroup s => x \in s => -x \in s.
proof. by move=> [+ mems_sub] - /mems_sub h /h {h}; rewrite sub0r. qed.

lemma subgroup_add (s : t fset) x y:
  subgroup s => x \in s => y \in s => x + y \in s.
proof.
move=> ^ /(subgroup_opp _ y) opp_y [_ mems_sub] /mems_sub + /opp_y - h /h.
by rewrite opprK.
qed.

lemma subgroup_sub (s : t fset) x y:
  subgroup s => x \in s => y \in s => x - y \in s.
proof. by move=> [] _ /(_ x y). qed.

(**************************************************************************)
op gen x =
  oflist (filter (fun y=> exists n, y = intmul x n) enum)
axiomatized by genE.

lemma genP y x:
  y \in gen x <=> exists n, y = intmul x n.
proof. by rewrite genE mem_oflist mem_filter enumP /=. qed.

lemma mem0_gen x: zeror \in gen x.
proof. by rewrite -(@mulr0z x) genP; exists 0. qed.

lemma mem1_gen x: x \in gen x.
proof. by rewrite -{2}(@mulr1z x) genP; exists 1. qed.

lemma subgroup_gen x: subgroup (gen x).
proof.
split=> [|y z]; first by exact/mem0_gen.
rewrite !genP=> - [log_y ->>] [log_z ->>].
by exists (log_y - log_z); rewrite -mulrNz mulrzz_add.
qed.

(**************************************************************************)
op coset1 g H =
  oflist (map (fun x=> g + x) (elems H))
axiomatized by coset1E.

lemma coset1P g H x:
  (x \in coset1 g H <=> x - g \in H).
proof.
rewrite coset1E mem_oflist mapP; split=> [[h] [] /= + ->>|xg_in_H].
+ by rewrite -memE addrAC subrr add0r.
by exists (x - g)=> /=; rewrite -memE xg_in_H /= addrCA subrr addr0.
qed.

lemma coset1_bij a b H:
  exists f,
    bijective f /\
    coset1 b H = image f (coset1 a H).
proof.
exists (fun h=> b - a + h); split.
+ exists (fun h=> a - b + h); rewrite /cancel /=; split=> x.
  + by rewrite addrA addrCA addrA addrCA subrr addr0 subrr add0r.
  by rewrite addrA addrCA addrA addrCA subrr addr0 subrr add0r.
apply/fsetP=> h; rewrite imageP coset1P; split=> [hb_in_H|].
+ exists (a + h - b); rewrite coset1P /=.
  rewrite -!addrA (@addrA (-a)) (@addrC (-a)) subrr add0r.
  rewrite (@addrC h (-b)) (@addrA b (-b) h) subrr add0r //=.
  by rewrite addrC -!addrA (@addrC (-a) a) subrr addr0.
move=> [ah] [] /= + <<-; rewrite coset1P (@addrC b) -addrA (@addrC _ (-b)).
by rewrite -addrA (@addrA b (-b)) subrr add0r addrC.
qed.

lemma card_coset1_eq a b H:
  card (coset1 a H) = card (coset1 b H).
proof.
by move: (coset1_bij a b H)=> [f] [] [g] [] + _ -> - /fcard_image_eq ->.
qed.

lemma coset10 H: coset1 zeror H = H.
proof. by apply/fsetP=> x; rewrite coset1P subr0. qed.

lemma card_coset1P a H:
  card (coset1 a H) = card H.
proof. by rewrite -{2}coset10; exact/card_coset1_eq. qed.

lemma coset1_cover H:
  H <> fset0 =>
  forall x, exists a, x \in coset1 a H.
proof.
move=> /mem_pick pick_in_H x; exists (x - pick H).
by rewrite coset1P opprD addrA subrr add0r opprK.
qed.

lemma coset1_disjoint x a b H:
  subgroup H =>
  x \in coset1 a H =>
  x \in coset1 b H =>
  coset1 a H = coset1 b H.
proof.
move=> ^sg_H [] z_in_H H_subr_closed; rewrite !coset1P=> ha hb.
move: (H_subr_closed _ _ ha hb); rewrite addrAC opprD opprK addrA subrr add0r.
move=> hab; apply/fsetP=> z; rewrite !coset1P; split=> [hza|hzb].
+ move: (H_subr_closed _ _ hza hab).
  by rewrite addrAC opprD opprK -!addrA subrr addr0.
move: (subgroup_opp _ _ sg_H hzb)=> hbz; move: (H_subr_closed _ _ hbz hab).
rewrite opprD opprK opprD opprK addrA -(@addrA (-z)) subrr addr0.
by move=>/(subgroup_opp _ _ sg_H); rewrite opprD opprK.
qed.

lemma mem_coset1 g (H : t fset):
  zeror \in H =>
  g \in coset1 g H.
proof. by move=> memH_0r; rewrite coset1P subrr. qed.

(**************************************************************************)
op cosets H = oflist (map (fun g=> coset1 g H) enum)
axiomatized by cosetsE.

lemma cosetsP X H:
  X \in cosets H <=>
  exists x, X = coset1 x H.
proof.
by rewrite cosetsE mem_oflist mapP; apply/exists_iff=> /= x; rewrite enumP.
qed.

lemma mem_cosets H: H \in cosets H.
proof. by rewrite cosetsP; exists zeror; rewrite coset10. qed.

lemma cosets_partition H:
  subgroup H =>
  (forall x, exists X, X \in cosets H /\ x \in X) /\
  (forall g X Y, X \in cosets H => Y \in cosets H => g \in X => g \in Y => X = Y).
proof.
move=> hH; split=> [x|g X Y].
+ exists (coset1 x H); rewrite mem_coset1 //=; first by move: hH=> [].
  by rewrite cosetsE mem_oflist mapP /=; exists x; rewrite enumP.
by move=> /cosetsP [x] ->> /cosetsP [y] ->> hx hy; exact/(coset1_disjoint g).
qed.

lemma union_cosets H:
  subgroup H =>
  fold (fun gH X=> gH `|` X) fset0 (cosets H) = (oflist enum).
proof.
move=> /cosets_partition []; move: (cosets H)=> {H}.
move=> Xs Xs_cover Xs_disjoint; apply/fsetP=> x; rewrite mem_oflist enumP /=.
move: (Xs_cover x)=> [] X0 [] X0_in_Xs x_in_X0 {Xs_cover Xs_disjoint}.
elim/fset_ind: Xs X0_in_Xs=> [|X Xs X_notin_Xs ih].
+ by rewrite in_fset0.
rewrite (@foldC X _ fset0 (Xs `|` fset1 X)) /=.
+ by move=> X' Y' Z' /=; rewrite fsetUCA.
+ by rewrite in_fsetU1.
rewrite fsetDK (: Xs `\` fset1 X = Xs) 2:in_fsetU1 2:in_fsetU.
+ by apply/fsetP=> y; rewrite in_fsetD1; case: (y = X)=> [->> //=|//=].
by case=> [/ih -> //=|->>]; rewrite x_in_X0.
qed.

lemma card_cosets H:
  subgroup H =>
  card (fold (fun gH X=> gH `|` X) fset0 (cosets H)) = card.
proof.
move=> /union_cosets ->; rewrite cardE /card.
by apply/perm_eq_size/perm_eq_sym; rewrite -{1}(undup_id enum_uniq) oflistK.
qed.
