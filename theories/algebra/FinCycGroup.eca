require import Ring List FSet Int IntDiv.
require (*--*) FinType.

pragma -oldip. pragma +implicits.

(**************************************************************************)
clone include Ring.ZModule.

op g     : {  t  | forall x, exists n, x = intmul g n } as gS.
op order : { int |    0 < order
                   /\ intmul g order = zeror
                   /\ (forall n, 0 < n < order => intmul g n <> zeror) }
           as orderS.

lemma gt0_order: 0 < order by move: orderS=> [].

lemma gorder_eq0r: intmul g order = zeror by move: orderS=> [].

lemma order_argmin n: 0 < n < order => intmul g n <> zeror.
proof. by move: orderS n=> []. qed.

(**************************************************************************)
(* TODO: Not sure if the mulgX lemmas are useful.
   The ones we want say "g^n = 0 <=> order %| n" *)
lemma mulgn_cyclic m k:
  0 <= k =>
  intmul g m = zeror =>
  intmul g (k * m) = zeror.
proof.
move=> + gm_eq_0; elim: k=> [|k ge0_k ih]; first by rewrite mulr0z.
by rewrite mulzDl /= -mulrzz_add ih gm_eq_0 addr0.
qed.

lemma mulgz_cyclic m k:
  intmul g m = zeror =>
  intmul g (k * m) = zeror.
proof.
case: (0 <= k)=> [/(mulgn_cyclic m) //=|].
rewrite -oppz_le0 -ltzNge=> /ltzW + gm_0 - /(mulgn_cyclic m _) /(_ gm_0).
by rewrite IntID.mulNr mulrNz oppr_eq0.
qed.

lemma mulgz_modz m n:
  intmul g m = zeror =>
  intmul g n = intmul g (n %% m).
proof.
by rewrite {1}(@divz_eq n m) -mulrzz_add=> /mulgz_cyclic ->; exact/add0r.
qed.

lemma gz_mod n: intmul g n = intmul g (n %% order).
proof. exact/mulgz_modz/gorder_eq0r. qed.

(**************************************************************************)
(** Note: This is also the witness bijection between `t` and `Z_{order}` **)
op enum = map (intmul g) (range 0 order) axiomatized by enumE.

lemma enum_universal x: x \in enum.
proof.
move: (gS x)=> [n]; rewrite gz_mod enumE mapP=> ->; exists (n %% order)=> //=.
by rewrite mem_range modz_ge0 1:[smt(gt0_order)] //= ltz_pmod gt0_order.
qed.

lemma exp_pinj_le m n:
  0 <= m <= n < order =>
  intmul g m = intmul g n =>
  m = n.
proof.
move=> hmn; rewrite eq_sym -subr_eq0 -mulrNz mulrzz_add.
case: (m = n)=> //= m_neq_n.
have // := order_argmin (n - m) _.
smt().
qed.

lemma exp_pinj m n:
  0 <= m < order =>
  0 <= n < order =>
  intmul g m = intmul g n =>
  m = n.
proof.
case: (m <= n)=> [le_m_n|le_n_m] hm hn.
+ by apply/exp_pinj_le=> /#.
by rewrite eq_sym (@eq_sym m); apply/exp_pinj_le=> /#.
qed.

lemma uniq_enum: uniq enum.
proof.
rewrite enumE; apply/map_inj_in_uniq.
+ by move=> x y; rewrite !mem_range; exact/exp_pinj.
exact/range_uniq.
qed.

lemma enumS x: count (pred1 x) enum = 1.
proof. by rewrite count_uniq_mem 1:uniq_enum enum_universal. qed.

clone include FinType with
  type t  <- t,
  op enum <- enum
proof enum_spec by exact/enumS.

lemma card_is_order: card = order.
proof. by rewrite /card enumE size_map size_range [smt(gt0_order)]. qed.

(**************************************************************************)
(* The rest of this file is currently experimentation
   with Lagrange-related facts. They don't need cyclicity                 *)
(**************************************************************************)
op subgroup (s : t fset) =
  zeror \in s /\
  forall x y, x \in s => y \in s => (x - y) \in s.

lemma subgroup0 (s : t fset):
  subgroup s => zeror \in s.
proof. by move=> []. qed.

lemma subgroup_opp (s : t fset) x:
  subgroup s => x \in s => -x \in s.
proof. by move=> [+ mems_sub] - /mems_sub h /h {h}; rewrite sub0r. qed.

lemma subgroup_add (s : t fset) x y:
  subgroup s => x \in s => y \in s => x + y \in s.
proof.
move=> ^ /(subgroup_opp _ y) opp_y [_ mems_sub] /mems_sub + /opp_y - h /h.
by rewrite opprK.
qed.

lemma subgroup_sub (s : t fset) x y:
  subgroup s => x \in s => y \in s => x - y \in s.
proof. by move=> [] _ /(_ x y). qed.

(**************************************************************************)
op gen x =
  oflist (filter (fun y=> exists n, y = intmul x n) enum)
axiomatized by genE.

lemma genP y x:
  y \in gen x <=> exists n, y = intmul x n.
proof. by rewrite genE mem_oflist mem_filter enumP /=. qed.

lemma mem0_gen x: zeror \in gen x.
proof. by rewrite -(@mulr0z x) genP; exists 0. qed.

lemma mem1_gen x: x \in gen x.
proof. by rewrite -{2}(@mulr1z x) genP; exists 1. qed.

lemma subgroup_gen x: subgroup (gen x).
proof.
split=> [|y z]; first by exact/mem0_gen.
rewrite !genP=> - [log_y ->>] [log_z ->>].
by exists (log_y - log_z); rewrite -mulrNz mulrzz_add.
qed.

(**************************************************************************)
op coset1 g H =
  oflist (map (fun x=> g + x) (elems H))
axiomatized by coset1E.

lemma coset1P g H x:
  (x \in coset1 g H <=> x - g \in H).
proof.
rewrite coset1E mem_oflist mapP; split=> [[h] [] /= + ->>|xg_in_H].
+ by rewrite -memE addrAC subrr add0r.
by exists (x - g)=> /=; rewrite -memE xg_in_H /= addrCA subrr addr0.
qed.

lemma coset1_bij a b H:
  exists f,
    bijective f /\
    coset1 b H = image f (coset1 a H).
proof.
exists (fun h=> b - a + h); split.
+ exists (fun h=> a - b + h); rewrite /cancel /=; split=> x.
  + by rewrite addrA addrCA addrA addrCA subrr addr0 subrr add0r.
  by rewrite addrA addrCA addrA addrCA subrr addr0 subrr add0r.
apply/fsetP=> h; rewrite imageP coset1P; split=> [hb_in_H|].
+ exists (a + h - b); rewrite coset1P /=.
  rewrite -!addrA (@addrA (-a)) (@addrC (-a)) subrr add0r.
  rewrite (@addrC h (-b)) (@addrA b (-b) h) subrr add0r //=.
  by rewrite addrC -!addrA (@addrC (-a) a) subrr addr0.
move=> [ah] [] /= + <<-; rewrite coset1P (@addrC b) -addrA (@addrC _ (-b)).
by rewrite -addrA (@addrA b (-b)) subrr add0r addrC.
qed.

lemma card_coset1_eq a b H:
  card (coset1 a H) = card (coset1 b H).
proof.
by move: (coset1_bij a b H)=> [f] [] [g] [] + _ -> - /fcard_image_eq ->.
qed.

lemma coset10 H: coset1 zeror H = H.
proof. by apply/fsetP=> x; rewrite coset1P subr0. qed.

lemma card_coset1P a H:
  card (coset1 a H) = card H.
proof. by rewrite -{2}coset10; exact/card_coset1_eq. qed.

lemma coset1_cover H:
  H <> fset0 =>
  forall x, exists a, x \in coset1 a H.
proof.
move=> /mem_pick pick_in_H x; exists (x - pick H).
by rewrite coset1P opprD addrA subrr add0r opprK.
qed.

lemma coset1_disjoint x a b H:
  subgroup H =>
  x \in coset1 a H =>
  x \in coset1 b H =>
  coset1 a H = coset1 b H.
proof.
move=> ^sg_H [] z_in_H H_subr_closed; rewrite !coset1P=> ha hb.
move: (H_subr_closed _ _ ha hb); rewrite addrAC opprD opprK addrA subrr add0r.
move=> hab; apply/fsetP=> z; rewrite !coset1P; split=> [hza|hzb].
+ move: (H_subr_closed _ _ hza hab).
  by rewrite addrAC opprD opprK -!addrA subrr addr0.
move: (subgroup_opp _ _ sg_H hzb)=> hbz; move: (H_subr_closed _ _ hbz hab).
rewrite opprD opprK opprD opprK addrA -(@addrA (-z)) subrr addr0.
by move=>/(subgroup_opp _ _ sg_H); rewrite opprD opprK.
qed.

lemma mem_coset1 g (H : t fset):
  zeror \in H =>
  g \in coset1 g H.
proof. by move=> memH_0r; rewrite coset1P subrr. qed.

(**************************************************************************)
op cosets H = oflist (map (fun g=> coset1 g H) enum)
axiomatized by cosetsE.

lemma cosetsP X H:
  X \in cosets H <=>
  exists x, X = coset1 x H.
proof.
by rewrite cosetsE mem_oflist mapP; apply/exists_iff=> /= x; rewrite enumP.
qed.

lemma mem_cosets H: H \in cosets H.
proof. by rewrite cosetsP; exists zeror; rewrite coset10. qed.

lemma cosets_partition H:
  subgroup H =>
  (forall x, exists X, X \in cosets H /\ x \in X) /\
  (forall g X Y, X \in cosets H => Y \in cosets H => g \in X => g \in Y => X = Y).
proof.
move=> hH; split=> [x|g X Y].
+ exists (coset1 x H); rewrite mem_coset1 //=; first by move: hH=> [].
  by rewrite cosetsE mem_oflist mapP /=; exists x; rewrite enumP.
by move=> /cosetsP [x] ->> /cosetsP [y] ->> hx hy; exact/(coset1_disjoint g).
qed.

lemma union_cosets H:
  subgroup H =>
  fold (fun gH X=> gH `|` X) fset0 (cosets H) = (oflist enum).
proof.
move=> /cosets_partition []; move: (cosets H)=> {H}.
move=> Xs Xs_cover Xs_disjoint; apply/fsetP=> x; rewrite mem_oflist enumP /=.
move: (Xs_cover x)=> [] X0 [] X0_in_Xs x_in_X0 {Xs_cover Xs_disjoint}.
elim/fset_ind: Xs X0_in_Xs=> [|X Xs X_notin_Xs ih].
+ by rewrite in_fset0.
rewrite (@foldC X _ fset0 (Xs `|` fset1 X)) /=.
+ by move=> X' Y' Z' /=; rewrite fsetUCA.
+ by rewrite in_fsetU1.
rewrite fsetDK (: Xs `\` fset1 X = Xs) 2:in_fsetU1 2:in_fsetU.
+ by apply/fsetP=> y; rewrite in_fsetD1; case: (y = X)=> [->> //=|//=].
by case=> [/ih -> //=|->>]; rewrite x_in_X0.
qed.

lemma card_cosets H:
  subgroup H =>
  card (fold (fun gH X=> gH `|` X) fset0 (cosets H)) = card.
proof.
move=> /union_cosets ->; rewrite cardE /card.
by apply/perm_eq_size/perm_eq_sym; rewrite -{1}(undup_id enum_uniq) oflistK.
qed.
